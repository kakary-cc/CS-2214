$date
	Thu Sep 29 12:47:32 2022
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module adder_subtractor_test $end
$var wire 4 ! S_expected [3:0] $end
$var wire 4 " S_actual [3:0] $end
$var wire 1 # Cout $end
$var reg 4 $ A [3:0] $end
$var reg 4 % B [3:0] $end
$var reg 1 & Op $end
$scope module adder $end
$var wire 4 ' A [3:0] $end
$var wire 4 ( B [3:0] $end
$var wire 1 & Op $end
$var wire 4 ) signed_B [3:0] $end
$var wire 4 * S [3:0] $end
$var wire 1 # Cout $end
$var wire 1 + C3 $end
$var wire 1 , C2 $end
$var wire 1 - C1 $end
$scope module FA1 $end
$var wire 1 . A $end
$var wire 1 / B $end
$var wire 1 0 Cin $end
$var wire 1 - Cout $end
$var wire 1 1 S $end
$upscope $end
$scope module FA2 $end
$var wire 1 2 A $end
$var wire 1 3 B $end
$var wire 1 - Cin $end
$var wire 1 , Cout $end
$var wire 1 4 S $end
$upscope $end
$scope module FA3 $end
$var wire 1 5 A $end
$var wire 1 6 B $end
$var wire 1 , Cin $end
$var wire 1 + Cout $end
$var wire 1 7 S $end
$upscope $end
$scope module FA4 $end
$var wire 1 8 A $end
$var wire 1 9 B $end
$var wire 1 + Cin $end
$var wire 1 # Cout $end
$var wire 1 : S $end
$upscope $end
$upscope $end
$scope task check $end
$var reg 4 ; a [3:0] $end
$var reg 4 < actual [3:0] $end
$var reg 4 = b [3:0] $end
$var reg 4 > expected [3:0] $end
$var reg 1 ? op $end
$upscope $end
$scope task test $end
$var reg 4 @ a [3:0] $end
$var reg 4 A b [3:0] $end
$var reg 1 B op $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
xB
bx A
bx @
x?
bx >
bx =
bx <
bx ;
0:
09
08
07
06
05
04
03
02
01
00
0/
0.
0-
0,
0+
b0 *
b0 )
b0 (
b0 '
0&
b0 %
b0 $
0#
b0 "
b0 !
$end
#200
b1 A
b1 @
0B
#400
14
1-
b10 "
b10 *
01
1/
b10 !
b1 )
1.
b1 %
b1 (
b1 $
b1 '
#600
b10 >
b10 <
b1 =
b1 ;
0?
#800
1B
#1000
1#
1+
04
1,
07
0:
b0 !
0/
13
16
19
b0 "
b0 *
01
b1110 )
10
1&
#1200
b0 >
b0 <
1?
#1400
b101 A
b10 @
0B
#1600
0+
17
0,
11
0:
0#
0-
b111 "
b111 *
14
1/
03
09
b111 !
b101 )
00
0.
12
0&
b101 %
b101 (
b10 $
b10 '
#1800
b111 >
b111 <
b101 =
b10 ;
0?
#2000
1B
#2200
04
1,
17
1:
0-
b1101 !
0/
13
06
19
b1101 "
b1101 *
11
b1010 )
10
1&
#2400
b1101 >
b1101 <
1?
#2600
b1100 A
b100 @
0B
#2800
1#
0:
0,
1+
04
07
03
16
b0 "
b0 *
01
b0 !
b1100 )
00
02
15
0&
b1100 %
b1100 (
b100 $
b100 '
#3000
b0 >
b0 <
b1100 =
b100 ;
0?
#3200
1B
#3400
1,
1+
1-
04
07
1:
0#
b1000 !
1/
13
06
09
b1000 "
b1000 *
01
b11 )
10
1&
#3600
b1000 >
b1000 <
1?
#3800
b111 A
b111 @
0B
#4000
17
b1110 "
b1110 *
14
16
b1110 !
b111 )
00
1.
12
0&
b111 %
b111 (
b111 $
b111 '
#4200
b1110 >
b1110 <
b111 =
b111 ;
0?
#4400
1B
#4600
04
07
0:
1#
b0 !
0/
03
06
19
b0 "
b0 *
01
b1000 )
10
1&
#4800
b0 >
b0 <
1?
#5000
b100 A
#5200
11
b11 "
b11 *
14
1/
13
b11 !
b1011 )
b100 %
b100 (
#5400
b11 >
b11 <
b100 =
#5600
b0 A
#5800
b111 "
b111 *
17
16
b111 !
b1111 )
b0 %
b0 (
#6000
b111 >
b111 <
b0 =
#6200
b11 @
#6400
b11 "
b11 *
07
b11 !
05
b11 $
b11 '
#6600
b11 >
b11 <
b11 ;
#6800
